from RedeNeuronal import Networkimport numpy as npclass Gene:    def __init__(self, network: Network): #dna: list):        self.network = network        self._fitness_score = 0        self.left_garbage = None        self.life_genaration = 1    def get_dna(self):        dna = []        for pesos in self.network.weights:            dna.extend(pesos.flatten())        for bias in self.network.bias:            dna.extend(bias.flatten())        return dna    def set_dna(self, dna: list):        tamanhos = self.network.sizes        indice = 0  # Índice inicial para percorrer o DNA        # Atualiza os pesos na rede neural a partir do DNA        for i in range(len(tamanhos) - 1):            num_pesos = tamanhos[i + 1] * tamanhos[i]  # Número de pesos nesta camada            self.network.weights[i] = np.array(dna[indice:indice + num_pesos], dtype=np.float64).reshape((tamanhos[i + 1], tamanhos[i]))            indice += num_pesos  # Atualiza o índice inicial para o próximo peso        # Atualiza os bias na rede neural a partir do DNA        for i in range(len(tamanhos) - 1):            num_bias = tamanhos[i + 1]  # Número de bias nesta camada            self.network.bias[i] = np.array(dna[indice:indice + num_bias]).reshape((tamanhos[i + 1], 1))            indice += num_bias  # Atualiza o índice inicial para o próximo bias    def get_network(self):        return self.network    def set_left_garbage(self, left_garbage):        self.left_garbage = left_garbage    def get_left_garbage(self):        return self.left_garbage    def get_fitness_score(self):        return self._fitness_score    def set_fitness_score(self, fitness_score):        self._fitness_score = fitness_score    def reset_fitness_score(self):        self._fitness_score = 0    def get_life_genaration(self):        return self.life_genaration    def increment_life_genaration(self):        self.life_genaration += 1    def set_dna_position(self, position, value):        self._dna[position] = value    def catch_garbage(self):        self._fitness_score += 5    def bad_move(self):        if self._fitness_score > 0:            self._fitness_score -= 1    def move(self, inputs):        movimento_indice, movimento_str, outputs, hidden_values, y_hat = self.network.feedforward(inputs)        return movimento_indice    def evaluate_fitness(self):        self.reset_fitness_score()        self.catch_garbage()        self.bad_move()