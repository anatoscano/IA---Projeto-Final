import numpy as npdef relu(a):    return np.maximum(0, a)def softmax(a):    exp = np.exp(a)    return exp / exp.sum(axis=0)class Network:    def __init__(self, sizes):        self.num_layers = len(sizes)        self.sizes = sizes        self.bias = [np.random.randn(y, 1).astype(np.float64) for y in sizes[1:]]        self.weights = [np.random.randn(y,x).astype(np.float64) for x,y in zip(sizes[:-1], sizes[1:])]    def feedforward(self, inputs):        movimentos = {0:'down', 1:'right', 2:'up', 3:'left'}        a = np.array(inputs, dtype=np.float64).reshape(-1, 1) #converte os inputs num array com elementos do tipo float64, transforma o array numa coluna        hidden_values = [a]        #print("hidden_values:", hidden_values)        for b, w in zip(self.bias[:-1], self.weights[:-1]):            z = np.dot(w, a) + b            a = relu(z)            hidden_values.append(a)         #   print("hidden_values:", hidden_values)        #print("tipo w:", w.dtype)        #print("tipo a:", a.dtype)        #print("tipo b:", b.dtype)        #print("shapes de pesos e bias para saída:")        #print(self.weights[-1].shape, a.shape, self.bias[-1].shape)        output = np.dot(self.weights[-1], a) + self.bias[-1]        outputs = softmax(output)        y_hat = np.argmax(outputs) #retorna a posição com o maior valor        movimento_indice = min(max(y_hat, 0), 3)        movimento_str = movimentos[movimento_indice]        return movimento_indice, movimento_str, outputs, hidden_values, y_hat    def get_weights_and_bias(self):        return self.weights, self.biasnet = Network([4, 6, 4])inputs = np.array([0, 0, 1, 1])[:, None]movimento_indice, movimento_str, outputs, hidden_values, y_hat = net.feedforward(inputs)#print("Hidden Values:", hidden_values)#print("Outputs:", outputs)#print("y_hat:", y_hat)#print("Movimento Index:", movimento_indice)#print("Movimento String:", movimento_str)print("Shapes dos pesos e bias depois de começarem:")print("Weights shapes:", [w.shape for w in net.weights])print("Bias shapes:", [b.shape for b in net.bias])