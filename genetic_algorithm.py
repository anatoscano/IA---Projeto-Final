from Gene import Geneimport randomimport numpy as npfrom RedeNeuronal import Network# Constants used in the genetic algorithm.NUM_OF_GENES = 200INPUT_SIZE = 4HIDDEN_LAYER_SIZE = 6OUTPUT_SIZE = 4NUM_OF_GENERATIONS = 20  # -> Number of generationsTOP_GENES = 80  # -> Top genes to be selected for crossoverMUTATION_RATE = 0.05MAX_LIFE_GENERATION = 100CROSSOVER_K_POINTS = 1#GENE_POSSIBILITIES = ['left', 'right', 'up', 'down']def create_initial_genes():    genes = []    for i in range(NUM_OF_GENES):        net = Network([INPUT_SIZE, HIDDEN_LAYER_SIZE, OUTPUT_SIZE])        gene = Gene(net)        genes.append(gene)    return genesdef crossover(parent1: Gene, parent2: Gene) -> Gene:    dna1 = parent1.get_dna()    dna2 = parent2.get_dna()    crossover_point = random.randint(0, len(dna1) - 1)  #crossover do dna1    dna_novo = dna1[:crossover_point] + dna2[crossover_point:]  #combinaÃ§ao dos 2dna    net = Network(parent1.get_network().sizes)  #nova rede com a mesma estrutura do pai1    filho = Gene(net)    filho.set_dna(dna_novo)    return filhodef mutate(gene: Gene) -> Gene:    dna = gene.get_dna()    for i in range(len(dna)):        if random.random() < MUTATION_RATE:            dna[i] += np.random.normal()    gene.set_dna(dna)    return genedef generate_next_generation(genes: list[Gene]) -> list[Gene]:    proxima_geracao = []    top_genes = sorted(genes, key=lambda gene: gene.get_fitness_score(), reverse=True)[:TOP_GENES] #selecionar os melhores genes tendo em conta o fitness_score    proxima_geracao.extend(top_genes)    while len(proxima_geracao) < NUM_OF_GENES:        parent1, parent2 = random.choices(top_genes, k=2)        filho = crossover(parent1, parent2)        filho = mutate(filho)        proxima_geracao.append(filho)    return proxima_geracao